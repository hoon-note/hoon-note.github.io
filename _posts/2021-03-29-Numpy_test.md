---
layout: single
title: "Python Numpy"
---


```python
import numpy as np
```

## numpy의 ndarray는 한가지 자료형만 원소로 저장함
<b>한가지 자료형</b>을 원소로 저장하므로 원소들을 동일한 크기의 메모리를 점유하며, <br>
<b>인접한 공간에 원소들이 저장</b>되기 때문에 각 원소들을 빠르게 순회할 수 있다<br>
1차원배열은 Vector, 2차원배열은 Matrix, 3차원 이상은 Tensor 등으로 불린다

## Jupyter notebook 작업디렉토리 지정하여 실행하기
cmd 창에서 jupyter notebook --notebook-dir=C:\\test<enter>


```python
a = np.array([1,2,3,4])
a
type(a[0])
```




    numpy.int32




```python
a = np.array([1,2,3,4], float) # 자료형 1개(int,float,str 등)를 지정할 수 있다
a
```




    array([1., 2., 3., 4.])




```python
a = np.array([1, 3.14, 5, 20]) # 자동으로 모두 float 형으로 저장됨
a
```




    array([ 1.  ,  3.14,  5.  , 20.  ])




```python
a = np.array([1,2,3,4], dtype=str)  # 명시적으로 문자열로  저장함
a
```




    array(['1', '2', '3', '4'], dtype='<U1')




```python
a = np.array([1,'a', 1.2, 'hello']) # 자동으로 모두 str 형으로 저장됨
a
```




    array(['1', 'a', '1.2', 'hello'], dtype='<U11')




```python
a = np.array([1,2,3.0,'4'], float) # 모두 float 형으로 저장됨
a
```




    array([1., 2., 3., 4.])




```python
a = np.array([1,2,3.0,'4', 'hello'], float) # 오류
a
```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    <ipython-input-213-6a7e9f283424> in <module>
    ----> 1 a = np.array([1,2,3.0,'4', 'hello'], float) #
          2 a
    

    ValueError: could not convert string to float: 'hello'



```python
a = np.array([1,2,3.0,'4'], np.float16) # np. 을 입력하고 [TAB]을 눌러 코드 힌트 확인
a
```




    array([1., 2., 3., 4.], dtype=float16)




```python
a.dtype # 자료형을 확인할 수 있다
```




    dtype('float16')




```python
a.shape  # 몇행, 몇열인지 확인
```




    (4,)




```python
a.ndim  # 배열이 몇차원인지 확인
```




    1




```python
a.size # 원소의 수
```




    4



## Shape Handling


```python
import numpy as np
a = np.random.random(16)
a.shape
```




    (16,)




```python
a.reshape(4,4)
```




    array([[0.29864899, 0.97797878, 0.97757664, 0.82528197],
           [0.97005236, 0.68981594, 0.74376287, 0.52806184],
           [0.71992545, 0.89084454, 0.44325719, 0.62478565],
           [0.93677626, 0.0587959 , 0.3241869 , 0.37243257]])




```python
a.reshape(8,2)
```




    array([[0.29864899, 0.97797878],
           [0.97757664, 0.82528197],
           [0.97005236, 0.68981594],
           [0.74376287, 0.52806184],
           [0.71992545, 0.89084454],
           [0.44325719, 0.62478565],
           [0.93677626, 0.0587959 ],
           [0.3241869 , 0.37243257]])




```python
a.shape=(4,4)
a
```




    array([[0.29864899, 0.97797878, 0.97757664, 0.82528197],
           [0.97005236, 0.68981594, 0.74376287, 0.52806184],
           [0.71992545, 0.89084454, 0.44325719, 0.62478565],
           [0.93677626, 0.0587959 , 0.3241869 , 0.37243257]])




```python
a.shape =(16,)
a
```




    array([0.29864899, 0.97797878, 0.97757664, 0.82528197, 0.97005236,
           0.68981594, 0.74376287, 0.52806184, 0.71992545, 0.89084454,
           0.44325719, 0.62478565, 0.93677626, 0.0587959 , 0.3241869 ,
           0.37243257])




```python
a.reshape(4,4)
```




    array([[0.29864899, 0.97797878, 0.97757664, 0.82528197],
           [0.97005236, 0.68981594, 0.74376287, 0.52806184],
           [0.71992545, 0.89084454, 0.44325719, 0.62478565],
           [0.93677626, 0.0587959 , 0.3241869 , 0.37243257]])




```python
a.ravel() # 원본을 1차원으로 변환
```




    array([0.29864899, 0.97797878, 0.97757664, 0.82528197, 0.97005236,
           0.68981594, 0.74376287, 0.52806184, 0.71992545, 0.89084454,
           0.44325719, 0.62478565, 0.93677626, 0.0587959 , 0.3241869 ,
           0.37243257])




```python
a
```




    array([0.29864899, 0.97797878, 0.97757664, 0.82528197, 0.97005236,
           0.68981594, 0.74376287, 0.52806184, 0.71992545, 0.89084454,
           0.44325719, 0.62478565, 0.93677626, 0.0587959 , 0.3241869 ,
           0.37243257])




```python
a.shape = (4,4) # 원본 변환
a
```




    array([[0.29864899, 0.97797878, 0.97757664, 0.82528197],
           [0.97005236, 0.68981594, 0.74376287, 0.52806184],
           [0.71992545, 0.89084454, 0.44325719, 0.62478565],
           [0.93677626, 0.0587959 , 0.3241869 , 0.37243257]])




```python
a.flatten() # 사본만 1차원으로 변환
```




    array([0.29864899, 0.97797878, 0.97757664, 0.82528197, 0.97005236,
           0.68981594, 0.74376287, 0.52806184, 0.71992545, 0.89084454,
           0.44325719, 0.62478565, 0.93677626, 0.0587959 , 0.3241869 ,
           0.37243257])




```python
a
```




    array([[0.29864899, 0.97797878, 0.97757664, 0.82528197],
           [0.97005236, 0.68981594, 0.74376287, 0.52806184],
           [0.71992545, 0.89084454, 0.44325719, 0.62478565],
           [0.93677626, 0.0587959 , 0.3241869 , 0.37243257]])




```python
a.flat # iterable 사본 생성
```




    <numpy.flatiter at 0x29262552030>




```python
a
```




    array([[0.29864899, 0.97797878, 0.97757664, 0.82528197],
           [0.97005236, 0.68981594, 0.74376287, 0.52806184],
           [0.71992545, 0.89084454, 0.44325719, 0.62478565],
           [0.93677626, 0.0587959 , 0.3241869 , 0.37243257]])




```python
for i in a.flat:  # iterable 사본을 이용한 배열원소 순회
    print(i)
```

    0.2986489909381632
    0.9779787783006687
    0.9775766388303663
    0.825281967375453
    0.9700523565386178
    0.6898159406535226
    0.7437628669801124
    0.5280618373691599
    0.7199254483244961
    0.8908445377162586
    0.44325718731628483
    0.6247856478026114
    0.9367762551645223
    0.05879589731849455
    0.324186895592251
    0.3724325679015227
    

## Indexing, Slicing


```python
a = np.random.randn(16).reshape(4,4)
a
```




    array([[ 0.03718595, -0.17375259,  0.56080511, -0.07821116],
           [ 0.54288064,  0.18554981,  0.82765453,  0.15613231],
           [ 1.3335647 , -2.23065747,  0.96039027, -0.32601034],
           [-1.29443404, -0.70033654, -0.27226776, -1.13828576]])




```python
import matplotlib.pyplot as plt
%matplotlib inline

a = np.random.randn(100)
plt.hist(a, bins=100)
```




    (array([1., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 1., 1., 0., 0., 0., 0.,
            3., 0., 1., 0., 1., 1., 0., 0., 2., 1., 0., 2., 0., 1., 1., 1., 1.,
            0., 4., 1., 2., 4., 1., 4., 5., 2., 1., 2., 1., 1., 1., 1., 3., 2.,
            5., 2., 1., 1., 1., 1., 2., 4., 1., 2., 2., 0., 1., 2., 1., 0., 2.,
            2., 0., 2., 2., 2., 2., 0., 0., 0., 2., 1., 0., 0., 0., 1., 0., 0.,
            0., 1., 1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 1.]),
     array([-2.29858316, -2.25146317, -2.20434317, -2.15722317, -2.11010317,
            -2.06298318, -2.01586318, -1.96874318, -1.92162318, -1.87450319,
            -1.82738319, -1.78026319, -1.73314319, -1.68602319, -1.6389032 ,
            -1.5917832 , -1.5446632 , -1.4975432 , -1.45042321, -1.40330321,
            -1.35618321, -1.30906321, -1.26194322, -1.21482322, -1.16770322,
            -1.12058322, -1.07346322, -1.02634323, -0.97922323, -0.93210323,
            -0.88498323, -0.83786324, -0.79074324, -0.74362324, -0.69650324,
            -0.64938325, -0.60226325, -0.55514325, -0.50802325, -0.46090325,
            -0.41378326, -0.36666326, -0.31954326, -0.27242326, -0.22530327,
            -0.17818327, -0.13106327, -0.08394327, -0.03682328,  0.01029672,
             0.05741672,  0.10453672,  0.15165671,  0.19877671,  0.24589671,
             0.29301671,  0.34013671,  0.3872567 ,  0.4343767 ,  0.4814967 ,
             0.5286167 ,  0.57573669,  0.62285669,  0.66997669,  0.71709669,
             0.76421668,  0.81133668,  0.85845668,  0.90557668,  0.95269668,
             0.99981667,  1.04693667,  1.09405667,  1.14117667,  1.18829666,
             1.23541666,  1.28253666,  1.32965666,  1.37677665,  1.42389665,
             1.47101665,  1.51813665,  1.56525665,  1.61237664,  1.65949664,
             1.70661664,  1.75373664,  1.80085663,  1.84797663,  1.89509663,
             1.94221663,  1.98933662,  2.03645662,  2.08357662,  2.13069662,
             2.17781662,  2.22493661,  2.27205661,  2.31917661,  2.36629661,
             2.4134166 ]),
     <a list of 100 Patch objects>)




![png](output_32_1.png)



```python
a[0][0]
```




    0.03718595147978414




```python
a[0,0]
```




    0.03718595147978414




```python
a[0,0] = 0.1
a[0][0] = 0.1
a
```




    array([[ 0.1       , -0.17375259,  0.56080511, -0.07821116],
           [ 0.54288064,  0.18554981,  0.82765453,  0.15613231],
           [ 1.3335647 , -2.23065747,  0.96039027, -0.32601034],
           [-1.29443404, -0.70033654, -0.27226776, -1.13828576]])




```python
a[5,0]  # 인덱스 초과
```


    ---------------------------------------------------------------------------

    IndexError                                Traceback (most recent call last)

    <ipython-input-30-946a3934e0d8> in <module>
    ----> 1 a[5,0]
    

    IndexError: index 5 is out of bounds for axis 0 with size 4



```python
a = np.arange(16).reshape(4,4)
a
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15]])




```python
a[2,:3]
```




    array([ 8,  9, 10])




```python
a[:2, :2]     # 연속된 행과 열 선택
```




    array([[0, 1],
           [4, 5]])




```python
a[[0,2], 1:3]     #비연속 행, 연속 컬럼
```




    array([[ 1,  2],
           [ 9, 10]])




```python
a[:3, [0,2]]     #연속 행, 비연속 컬럼
```




    array([[ 0,  2],
           [ 4,  6],
           [ 8, 10]])




```python
a[[0,1], [0,1]]  # 행, 열 지정자가 모두 나열형이면 모서리 원소 출력
```




    array([0, 5])




```python
a[5:10]    # 연속구간을 지정할 때는 배열의 범위를 벗어나도 오류는 없음
```




    array([], shape=(0, 4), dtype=int32)




```python
a[::2,::2]  # step 을 적용한 슬라이싱도 가능
```




    array([[ 0,  2],
           [ 8, 10]])




```python
a = np.arange(16).reshape(4,4)
a
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15]])




```python
# 위의 행렬에 대한 가로, 세로 합과 평균
a_s = a.sum(axis=0)
print('세로 합:', a_s, '세로 합의 평균:', a_s.mean())
```

    세로 합: [24 28 32 36] 세로 합의 평균: 30.0
    


```python
a_s = a.sum(axis=1)
print('가로 합:', a_s, '가로 합의 평균:', a_s.mean())
```

    가로 합: [ 6 22 38 54] 가로 합의 평균: 30.0
    


```python
print(a)
# 중간에 위치한 4개의 값에 대한 표준편차
a1 = a[[1,2], 1:3]
print('중간에 위치한 4개:')
print(a1)
print('평균:', a1.mean(), '표준편자:',a1.std())
```

    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]
     [12 13 14 15]]
    중간에 위치한 4개:
    [[ 5  6]
     [ 9 10]]
    평균: 7.5 표준편자: 2.0615528128088303
    


```python
# 1번행, 3번행의 후반부 값에 대한 평균값
a[[1,3],2:4].mean()
```




    10.5




```python
# 1,3번 컬럼의 중간 2개 값들에 대한 총합, 평균, 표준편차
print(a)
a[[1,2], [1,3]]
```

    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]
     [12 13 14 15]]
    




    array([ 5, 11])




```python
a1 = a[1:3, [1,3]]
print(a1)
print('총합:',a1.sum(), '평균:',a1.mean(), '편차:',a1.std())
```

    [[ 5  7]
     [ 9 11]]
    총합: 32 평균: 8.0 편차: 2.23606797749979
    

## 3개 이상의 ndarray로 분리하기(split)
np.split(arr, [2,3],axis=1)<br>
arr 행렬을 가로방향(axis=1)으로 쪼개서 3개의 ndarray를 생성한다<br>
0 ~ 2번 컬럼까지 한개의 배열이 되고, 2 ~ 3까지 한개가 되며, 3  ~끝까지 쪼개므로 총 3개가 된다<br>
[2,3]에 주어진 숫자는 컬럼 인덱스이며 stop 에 해당하므로 비포함이다


```python
a = np.arange(16).reshape(4,4)
print(a)
np.split(a, [2,3,4],axis=1)

```

    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]
     [12 13 14 15]]
    




    [array([[ 0,  1],
            [ 4,  5],
            [ 8,  9],
            [12, 13]]),
     array([[ 2],
            [ 6],
            [10],
            [14]]),
     array([[ 3],
            [ 7],
            [11],
            [15]]),
     array([], shape=(4, 0), dtype=int32)]



## Shallow vs Deep Copy


```python
a = np.arange(9).reshape(3,3)
a
```




    array([[0, 1, 2],
           [3, 4, 5],
           [6, 7, 8]])




```python
def change_element(matrix):
    matrix -= 4
    matrix[0] = 100
    print(matrix)
    
change_element(a)
print('원본:')
print(a)
```

    [[100 100 100]
     [ -5  -4  -3]
     [ -2  -1   0]]
    원본:
    [[100 100 100]
     [ -5  -4  -3]
     [ -2  -1   0]]
    


```python
a = np.arange(9).reshape(3,3)
a
```




    array([[0, 1, 2],
           [3, 4, 5],
           [6, 7, 8]])




```python
def change_zero(mat):
    #mat = np.zeros_like(mat)
    #mat = 0
    for i in range(3):
        mat[i] = 0

change_zero(a)

def change_int(mat):
    print('원본')
    print(a)
    n = 8
    for row in range(3):
        for col in range(3):
            mat[row,col] = n
            n -= 1

change_int(a)
print('원본')
print(a)
```

    원본
    [[0 0 0]
     [0 0 0]
     [0 0 0]]
    원본
    [[8 7 6]
     [5 4 3]
     [2 1 0]]
    

## 원본 배열과 동일하게 복사


```python
a = np.arange(6).reshape(2,3)
a
```




    array([[0, 1, 2],
           [3, 4, 5]])




```python
b = a
b[0] = 7
a
```




    array([[7, 7, 7],
           [3, 4, 5]])




```python
a = np.arange(6).reshape(2,3)
c = a.copy()
c[0] = 9
a
```




    array([[0, 1, 2],
           [3, 4, 5]])



## Broadcasting


```python
a = np.arange(6).reshape(2,3)
a
```




    array([[0, 1, 2],
           [3, 4, 5]])




```python
b = a+1
b
```




    array([[1, 2, 3],
           [4, 5, 6]])




```python
b = np.array([3,2,1])
a+b
```




    array([[3, 3, 3],
           [6, 6, 6]])




```python
b = np.array([[4],[5]])  # 열벡터(Column Vector)
a+b
```




    array([[ 4,  5,  6],
           [ 8,  9, 10]])



## Structured Array
일반적으로 numpy는 단일 자료형을 대상으로 배열을 생성한다<br>
그러므로 한 배열 안에 자료형이 다른 원소를 저장하면 대표형으로 형변환되어 저장된다
예를 들어, 정수와 실수를 함께 배열에 저장하면 모두 float 형으로 저장되며, 문자열과 숫자를 함께 동일 배열에 저장하면 모두 문자열 형태로 저장된다<br>
또한, numpy는 구조체 배열도 지원하므로 배열을 생성할 때 서로 다른 자료형을 지정하여 생성하면 지정된 자료형으로 유지된다


```python
# 구조체 배열이 아닌 일반배열을 선언하는 경우
mem = np.array([11,'홍길동','010-5214-5120'])
mem   # 위와같이 이질적인 자료형으로 ndarray를 생성하면 원래의 자료형으로 저장되지 않는다
# 배열의 모든 자료형이 dtype='<U13' 으로 자동으로 설정되어 있는데 
# 이는 Unicode문자 13개를 저장 가능한 원소를 의미한다
```




    array(['11', '홍길동', '010-5214-5120'], dtype='<U13')




```python
# 구조체 배열의 선언, 모든 원소의 자료형과 컬럼명을 지정할 수 있다
mem = np.array((11,'홍길동','010-5214-5120'), dtype=('int8,U12,U13'))
mem  # 
```




    array((11, '홍길동', '010-5214-5120'),
          dtype=[('f0', 'i1'), ('f1', '<U12'), ('f2', '<U13')])




```python
# 구조체 배열은 컬럼명도 자동으로 지정되므로 이를 이용할 수도 있다
mem['f1']
```




    array('홍길동', dtype='<U12')




```python
# 구조체 배열을 선언할 때 컬럼명도 함께 지정하기
mem = np.array([
    (11,'홍길동','010-5214-5120'), 
    (12,'홍준표','010-1260-2489')], 
    dtype=[('id','int'),('name','U12'),('phone','U13')]
)
mem[0]          # 한행 추출
mem['name']     # name 컬럼의 모든 값
```




    array(['홍길동', '홍준표'], dtype='<U12')




```python
# 컬럼명을 변경할 필요가 있다면...
mem.dtype.names = ['번호','이름','전화']
mem['이름']
```




    array(['홍길동', '홍준표'], dtype='<U12')




```python
import numpy as np
# 구조체 배열 실습(사원정보 검색) 번호, 이름, 부서번호, 커미션, 급여
emp = np.array([
    (11,'전두한',20,3.2,200),
    (12,'이순재',21,4.1,320),
    (13,'노태오',20,1.9,240),
    (14,'이명백',22,5.6,280),
    (15,'박근회',23,7.2,400)
], dtype=[('id','i4'),('name','U12'),('detpno','i4'),('comm','f2'),('sal','i4')]
)

for e in emp:
    print(e['name'])
```

    전두한
    이순재
    노태오
    이명백
    박근회
    




    1440




```python
category = input('번호로 검색(i), 이름으로 검색(n):')
if category=='i':
    num = int(input('번호:'))
    for e in emp:
        if e['id']==num:
            print(e)
            break
else:
    name = input('이름:')
    for e in emp:
        if e['name']==name:
            print(e)
            break
```

    번호로 검색(i), 이름으로 검색(n):n
    이름:이명백
    (14, '이명백', 22, 5.6, 280)
    


```python

# 구조체 배열을 파일에 저장하고 읽어오기
np.savetxt('D:/DataScience/emp.csv',emp,
           fmt='%d, %s, %d, %.1f, %d', header='id,name,deptno,comm,sal')

emp2 = np.loadtxt('D:/DataScience/emp.csv', delimiter=',', 
                  dtype={'names':('id','name','deptno','comm','sal'),
                         'formats':('i4','U12','i4','f4','i4')})

for e in emp2:
    print(e['name'])

```

     전두한
     이순재
     노태오
     이명백
     박근회
    


```python
def emp_list():
    emp2 = np.loadtxt('D:/DataScience/emp.csv', delimiter=',', 
                  dtype={'names':('id','name','deptno','comm','sal'),
                         'formats':('i4','U12','i4','f4','i4')})
    for e in emp2:
        print(e)
    
def add_emp(newemp): # 11, 전두한, 20, 3.2, 200
    emp = np.loadtxt('D:/DataScience/emp.csv', delimiter=',', 
                  dtype={'names':('id','name','deptno','comm','sal'),
                         'formats':('i4','U12','i4','f4','i4')})
    emplist = emp.tolist()
    #print(emplist)
    emplist.append(newemp)
    newarr = np.array( emplist, dtype=[('id','i4'),('name','U12'),('deptno','i4'),('comm','f2'),('sal','i4')])
    
    np.savetxt('D:/DataScience/emp.csv',newarr,
           fmt='%d,%s,%d,%.1f,%d', header='id,name,deptno,comm,sal')
    emp_list()
    
def delete_emp(id):
    emp = np.loadtxt('D:/DataScience/emp.csv', delimiter=',', 
                  dtype={'names':('id','name','deptno','comm','sal'),
                         'formats':('i4','U12','i4','f4','i4')})
    emplist = emp.tolist()  # 배열을 리스트로 변환
    for e in emplist:
        if e[0]==id:
            emplist.remove(e)
            break

    # 다시 리스트를 배열로 변환
    newarr = np.array(emplist, dtype=[('id','i4'),('name','U12'),('detpno','i4'),('comm','f2'),('sal','i4')])
    
    np.savetxt('D:/DataScience/emp.csv',newarr,
           fmt='%d, %s, %d, %.1f, %d', header='id,name,deptno,comm,sal')
    print('삭제 완료')
    emp_list()
    
# 기존 데이터 변경
def update_emp(emp):
    np.savetxt('D:/DataScience/emp.csv',emp,
           fmt='%d, %s, %d, %.1f, %d', header='id,name,deptno,comm,sal')
    print('변경완료')
    emp_list()
```


```python
# 삭제 함수 테스트
delete_emp(12)
emp3 = np.loadtxt('D:/DataScience/emp.csv', delimiter=',', 
                  dtype={'names':('id','name','deptno','comm','sal'),
                         'formats':('i4','U12','i4','f4','i4')})
```

    삭제 완료
    (11, '        전두한', 20, 3.2, 200)
    (13, '        노태오', 20, 1.9, 240)
    (14, '        이명백', 22, 5.6, 280)
    (15, '        박근회', 23, 7.2, 400)
    


```python
# 업데이트 함수 테스트
emp = np.loadtxt('D:/DataScience/emp.csv', delimiter=',', 
                  dtype={'names':('id','name','deptno','comm','sal'),
                         'formats':('i4','U12','i4','f4','i4')})
emp[1] = (12,'이순재', 11,0.2,123)
update_emp(emp)
    
```

    변경완료
    (11, '  전두한', 20, 3.2, 200)
    (12, ' 이순재', 11, 0.2, 123)
    (13, '  노태오', 20, 1.9, 240)
    (14, '  이명백', 22, 5.6, 280)
    (15, '  박근회', 23, 7.2, 400)
    


```python
# 추가함수 테스트
emp = np.array((16,'송창식',22,4.7,270),
     dtype=[('id','i4'),('name','U12'),('deptno','i4'),('comm','f2'),('sal','i4')]
)
add_emp(emp)
```

    (11, ' 전두한', 20, 3.2, 200)
    (12, ' 이순재', 21, 4.1, 320)
    (13, ' 노태오', 20, 1.9, 240)
    (14, ' 이명백', 22, 5.6, 280)
    (15, ' 박근회', 23, 7.2, 400)
    (16, '송창식', 22, 4.7, 270)
    


```python
import numpy as np
emp = np.loadtxt('D:/DataScience/emp.csv', delimiter=',', 
                  dtype={'names':('id','name','deptno','comm','sal'),
                         'formats':('i4','U12','i4','f4','i4')})

for e in emp:
    print(e)
    
comm = emp['comm']
sal = emp['sal']
axis_1_sum = comm+sal
print('사원별 지급액')
print(axis_1_sum)

comm_sum = emp['comm'].sum(axis=0)
sal_sum = emp['sal'].sum(axis=0)
print('comm총액:',comm_sum, 'sal총액:',sal_sum)
print('지출총액:',comm_sum+sal_sum)
```

    (11, ' 전두한', 20, 3.2, 200)
    (12, ' 이순재', 21, 4.1, 320)
    (13, ' 노태오', 20, 1.9, 240)
    (14, ' 이명백', 22, 5.6, 280)
    (15, ' 박근회', 23, 7.2, 400)
    (16, '송창식', 22, 4.7, 270)
    사원별 지급액
    [203.20000005 324.0999999  241.89999998 285.5999999  407.19999981
     274.69999981]
    comm총액: 26.7 sal총액: 1710
    지출총액: 1736.7000007629395
    

## ndarray 생성용 함수


```python
a = np.array([1,2,3,4])
a
```




    array([1, 2, 3, 4])




```python
np.arange(4)
```




    array([0, 1, 2, 3])




```python
np.arange(1,5)
```




    array([1, 2, 3, 4])




```python
np.arange(1,10,2)
```




    array([1, 3, 5, 7, 9])




```python
np.random.random(3)
```




    array([0.4838681 , 0.97762683, 0.03540169])




```python
np.random.random((2,2))
```




    array([[0.85502172, 0.18411288],
           [0.08427248, 0.61267469]])




```python
np.random.randn(5)   # 평균이 0이고, 편차가 1인 가우스 정규분표 값 생성
```




    array([ 0.85754857, -0.39180734,  0.02448693, -0.32678434, -0.14749257])




```python
a = np.random.randn(100)
```


```python
plt.hist(a, bins=100)
```




    (array([1., 0., 0., 0., 0., 0., 0., 1., 0., 0., 1., 0., 0., 0., 0., 0., 1.,
            2., 2., 0., 0., 1., 1., 1., 1., 0., 0., 2., 0., 2., 0., 2., 4., 3.,
            2., 1., 0., 1., 1., 0., 4., 0., 2., 2., 1., 5., 2., 0., 1., 3., 4.,
            4., 5., 1., 7., 0., 0., 1., 0., 0., 2., 1., 0., 2., 0., 3., 1., 2.,
            2., 2., 0., 2., 1., 0., 0., 1., 1., 0., 1., 0., 0., 0., 1., 0., 1.,
            1., 2., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 1.]),
     array([-2.45565086, -2.40628888, -2.3569269 , -2.30756493, -2.25820295,
            -2.20884098, -2.159479  , -2.11011702, -2.06075505, -2.01139307,
            -1.96203109, -1.91266912, -1.86330714, -1.81394517, -1.76458319,
            -1.71522121, -1.66585924, -1.61649726, -1.56713529, -1.51777331,
            -1.46841133, -1.41904936, -1.36968738, -1.3203254 , -1.27096343,
            -1.22160145, -1.17223948, -1.1228775 , -1.07351552, -1.02415355,
            -0.97479157, -0.9254296 , -0.87606762, -0.82670564, -0.77734367,
            -0.72798169, -0.67861971, -0.62925774, -0.57989576, -0.53053379,
            -0.48117181, -0.43180983, -0.38244786, -0.33308588, -0.28372391,
            -0.23436193, -0.18499995, -0.13563798, -0.086276  , -0.03691402,
             0.01244795,  0.06180993,  0.1111719 ,  0.16053388,  0.20989586,
             0.25925783,  0.30861981,  0.35798178,  0.40734376,  0.45670574,
             0.50606771,  0.55542969,  0.60479167,  0.65415364,  0.70351562,
             0.75287759,  0.80223957,  0.85160155,  0.90096352,  0.9503255 ,
             0.99968747,  1.04904945,  1.09841143,  1.1477734 ,  1.19713538,
             1.24649736,  1.29585933,  1.34522131,  1.39458328,  1.44394526,
             1.49330724,  1.54266921,  1.59203119,  1.64139316,  1.69075514,
             1.74011712,  1.78947909,  1.83884107,  1.88820305,  1.93756502,
             1.986927  ,  2.03628897,  2.08565095,  2.13501293,  2.1843749 ,
             2.23373688,  2.28309885,  2.33246083,  2.38182281,  2.43118478,
             2.48054676]),
     <a list of 100 Patch objects>)




![png](output_91_1.png)



```python
np.zeros(3)
```




    array([0., 0., 0.])




```python
np.zeros((2,4))
```




    array([[0., 0., 0., 0.],
           [0., 0., 0., 0.]])




```python
np.ones(4)
```




    array([1., 1., 1., 1.])




```python
# np.empty(shape, dtype=float)
np.empty([2,3])  # 원소를 초기화하지 않고 공간 할당만 수행하므로 쓰레기 값들이 저장되어 있음
```




    array([[0., 0., 0.],
           [0., 0., 0.]])




```python
a = np.arange(9)
a
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8])




```python
np.zeros_like(a)   # 기존 ndarray를 0으로 초기화
```




    array([0, 0, 0, 0, 0, 0, 0, 0, 0])




```python
np.ones_like(a)    # 기존 ndarray를 1으로 초기화
```




    array([1, 1, 1, 1, 1, 1, 1, 1, 1])




```python
np.empty(a)        # 기존 ndarray를 초기화 없이 기존 그대로
```




    array([], shape=(0, 1, 2, 3, 4, 5, 6, 7, 8), dtype=float64)




```python
np.identity(3)  # 단위행렬(대각선으로 1이면서 정방행렬)
```




    array([[1., 0., 0.],
           [0., 1., 0.],
           [0., 0., 1.]])




```python
np.eye(3,3)   # 대각선으로 1인 행렬(정방행렬일 필요는 없음)
```




    array([[1., 0., 0.],
           [0., 1., 0.],
           [0., 0., 1.]])




```python
np.eye(3,5)
```




    array([[1., 0., 0., 0., 0.],
           [0., 1., 0., 0., 0.],
           [0., 0., 1., 0., 0.]])




```python
np.eye(3,5,k=1)  # 대각선 시작 컬럼 지정
```




    array([[0., 1., 0., 0., 0.],
           [0., 0., 1., 0., 0.],
           [0., 0., 0., 1., 0.]])




```python
a = np.arange(16).reshape(4,4)
a
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15]])




```python
np.diag(a)     # 행렬의 대각선 값 추출
```




    array([ 0,  5, 10, 15])




```python
np.diag(a, k=2)   # 대각선 시작 컬럼
```




    array([2, 7])




```python
a = np.random.uniform(0,5,100)  # 0~5구간의 균등분포(정규분포와 구분)
plt.hist(a, bins=100)
```




    (array([1., 1., 1., 3., 0., 1., 2., 0., 1., 0., 0., 1., 0., 1., 1., 0., 2.,
            1., 3., 3., 3., 1., 0., 0., 3., 2., 1., 1., 1., 0., 1., 0., 2., 0.,
            0., 1., 0., 0., 0., 0., 0., 1., 2., 1., 0., 2., 1., 0., 1., 1., 1.,
            1., 1., 1., 0., 1., 0., 1., 0., 0., 0., 0., 0., 0., 2., 1., 2., 3.,
            2., 1., 1., 0., 2., 2., 0., 0., 1., 1., 2., 2., 2., 1., 0., 3., 2.,
            2., 0., 1., 1., 0., 0., 1., 1., 2., 1., 2., 2., 1., 0., 3.]),
     array([0.07565331, 0.12417992, 0.17270652, 0.22123313, 0.26975973,
            0.31828634, 0.36681294, 0.41533955, 0.46386615, 0.51239276,
            0.56091937, 0.60944597, 0.65797258, 0.70649918, 0.75502579,
            0.80355239, 0.852079  , 0.9006056 , 0.94913221, 0.99765881,
            1.04618542, 1.09471202, 1.14323863, 1.19176524, 1.24029184,
            1.28881845, 1.33734505, 1.38587166, 1.43439826, 1.48292487,
            1.53145147, 1.57997808, 1.62850468, 1.67703129, 1.72555789,
            1.7740845 , 1.82261111, 1.87113771, 1.91966432, 1.96819092,
            2.01671753, 2.06524413, 2.11377074, 2.16229734, 2.21082395,
            2.25935055, 2.30787716, 2.35640376, 2.40493037, 2.45345698,
            2.50198358, 2.55051019, 2.59903679, 2.6475634 , 2.69609   ,
            2.74461661, 2.79314321, 2.84166982, 2.89019642, 2.93872303,
            2.98724963, 3.03577624, 3.08430285, 3.13282945, 3.18135606,
            3.22988266, 3.27840927, 3.32693587, 3.37546248, 3.42398908,
            3.47251569, 3.52104229, 3.5695689 , 3.6180955 , 3.66662211,
            3.71514872, 3.76367532, 3.81220193, 3.86072853, 3.90925514,
            3.95778174, 4.00630835, 4.05483495, 4.10336156, 4.15188816,
            4.20041477, 4.24894137, 4.29746798, 4.34599459, 4.39452119,
            4.4430478 , 4.4915744 , 4.54010101, 4.58862761, 4.63715422,
            4.68568082, 4.73420743, 4.78273403, 4.83126064, 4.87978724,
            4.92831385]),
     <a list of 100 Patch objects>)




![png](output_107_1.png)



```python
a = np.random.normal(10,1,100)  # 평균:10, 편차:1 정규분포
print(a.mean())
plt.hist(a, bins=100)
```

    10.091269733292606
    




    (array([1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0.,
            1., 0., 0., 1., 1., 1., 0., 0., 1., 0., 3., 1., 1., 1., 2., 2., 1.,
            2., 1., 1., 0., 2., 3., 1., 2., 0., 3., 2., 2., 2., 5., 3., 2., 5.,
            2., 5., 2., 2., 2., 0., 4., 1., 3., 0., 2., 3., 2., 2., 0., 1., 2.,
            1., 0., 0., 1., 1., 2., 0., 1., 0., 1., 0., 1., 0., 1., 1., 0., 0.,
            1., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.]),
     array([ 7.5296524 ,  7.58075137,  7.63185033,  7.68294929,  7.73404826,
             7.78514722,  7.83624619,  7.88734515,  7.93844412,  7.98954308,
             8.04064204,  8.09174101,  8.14283997,  8.19393894,  8.2450379 ,
             8.29613687,  8.34723583,  8.39833479,  8.44943376,  8.50053272,
             8.55163169,  8.60273065,  8.65382962,  8.70492858,  8.75602754,
             8.80712651,  8.85822547,  8.90932444,  8.9604234 ,  9.01152237,
             9.06262133,  9.11372029,  9.16481926,  9.21591822,  9.26701719,
             9.31811615,  9.36921512,  9.42031408,  9.47141304,  9.52251201,
             9.57361097,  9.62470994,  9.6758089 ,  9.72690787,  9.77800683,
             9.82910579,  9.88020476,  9.93130372,  9.98240269, 10.03350165,
            10.08460062, 10.13569958, 10.18679854, 10.23789751, 10.28899647,
            10.34009544, 10.3911944 , 10.44229337, 10.49339233, 10.54449129,
            10.59559026, 10.64668922, 10.69778819, 10.74888715, 10.79998612,
            10.85108508, 10.90218404, 10.95328301, 11.00438197, 11.05548094,
            11.1065799 , 11.15767887, 11.20877783, 11.25987679, 11.31097576,
            11.36207472, 11.41317369, 11.46427265, 11.51537162, 11.56647058,
            11.61756954, 11.66866851, 11.71976747, 11.77086644, 11.8219654 ,
            11.87306437, 11.92416333, 11.97526229, 12.02636126, 12.07746022,
            12.12855919, 12.17965815, 12.23075712, 12.28185608, 12.33295504,
            12.38405401, 12.43515297, 12.48625194, 12.5373509 , 12.58844987,
            12.63954883]),
     <a list of 100 Patch objects>)




![png](output_108_2.png)



```python
# 합치기 실습
import numpy as np
data = np.genfromtxt('D:/DataScience/np_sample.csv', 
                     delimiter=',', names=True, dtype=int)
for i in data:
    print(i)
    
print( type(data[0]))  # void 형
    
_data = data.tolist()
arr = np.array(_data)
print( type(arr[0]))   # ndarray 형
sum_axis_1 = arr.sum(axis=1)
arr2 = np.hstack((arr, sum_axis_1.reshape(4,1)))

sum_axis_0 = arr2.sum(axis=0)
arr3 = np.vstack((arr2, sum_axis_0))
arr3
```

    (0, 1, 2, 3)
    (4, 5, 6, 7)
    (8, 9, 10, 11)
    (12, 13, 14, 15)
    <class 'numpy.void'>
    <class 'numpy.ndarray'>
    




    array([[  0,   1,   2,   3,   6],
           [  4,   5,   6,   7,  22],
           [  8,   9,  10,  11,  38],
           [ 12,  13,  14,  15,  54],
           [ 24,  28,  32,  36, 120]])




```python
a = np.random.randn(100)  # 평균:0, 편차: 1, (가우스 정규분포)
print(a.mean())
plt.hist(a, bins=100)
```

    -0.0019763230411737167
    




    (array([1., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 2., 0., 1., 1., 0., 0.,
            0., 0., 1., 1., 0., 0., 0., 1., 2., 2., 3., 1., 2., 1., 1., 2., 1.,
            0., 3., 3., 3., 2., 1., 2., 3., 1., 1., 2., 2., 3., 2., 0., 2., 4.,
            1., 5., 1., 2., 2., 2., 1., 7., 1., 1., 1., 4., 2., 1., 0., 0., 0.,
            0., 1., 2., 0., 0., 2., 1., 1., 0., 1., 0., 0., 0., 0., 0., 0., 0.,
            0., 1., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.]),
     array([-2.51197724, -2.45810541, -2.40423358, -2.35036175, -2.29648992,
            -2.24261809, -2.18874627, -2.13487444, -2.08100261, -2.02713078,
            -1.97325895, -1.91938712, -1.86551529, -1.81164346, -1.75777163,
            -1.7038998 , -1.65002797, -1.59615614, -1.54228431, -1.48841248,
            -1.43454065, -1.38066882, -1.32679699, -1.27292516, -1.21905333,
            -1.1651815 , -1.11130968, -1.05743785, -1.00356602, -0.94969419,
            -0.89582236, -0.84195053, -0.7880787 , -0.73420687, -0.68033504,
            -0.62646321, -0.57259138, -0.51871955, -0.46484772, -0.41097589,
            -0.35710406, -0.30323223, -0.2493604 , -0.19548857, -0.14161674,
            -0.08774492, -0.03387309,  0.01999874,  0.07387057,  0.1277424 ,
             0.18161423,  0.23548606,  0.28935789,  0.34322972,  0.39710155,
             0.45097338,  0.50484521,  0.55871704,  0.61258887,  0.6664607 ,
             0.72033253,  0.77420436,  0.82807619,  0.88194802,  0.93581984,
             0.98969167,  1.0435635 ,  1.09743533,  1.15130716,  1.20517899,
             1.25905082,  1.31292265,  1.36679448,  1.42066631,  1.47453814,
             1.52840997,  1.5822818 ,  1.63615363,  1.69002546,  1.74389729,
             1.79776912,  1.85164095,  1.90551278,  1.95938461,  2.01325643,
             2.06712826,  2.12100009,  2.17487192,  2.22874375,  2.28261558,
             2.33648741,  2.39035924,  2.44423107,  2.4981029 ,  2.55197473,
             2.60584656,  2.65971839,  2.71359022,  2.76746205,  2.82133388,
             2.87520571]),
     <a list of 100 Patch objects>)




![png](output_110_2.png)


## 수학, 통계 계산을 위한 함수


```python
a = np.arange(9).reshape(3,3)
a
```




    array([[0, 1, 2],
           [3, 4, 5],
           [6, 7, 8]])




```python
a.sum()
```




    36




```python
a.sum(axis=1)
```




    array([ 3, 12, 21])




```python
a.sum(axis=0)
```




    array([ 9, 12, 15])




```python
a[1].sum()
```




    12




```python
a[1,:2].sum()
```




    7




```python
a[1:3,2].sum()
```




    13




```python
a[:,1].sum()
```




    12



## 3차원 배열의 3축 구분
1차원의 경우 axis=0(열방향 축) 뿐이고,<br> 2차원의 경우에는 2개의 축 즉, axis=0(행방향 축), axis=1(열방향 축)으로 구성된다.<br>
3차원구조는 axis=0(면방향 축), axis=1(행방향 축), axis=2(열방향 축)으로 구성된다<br>
3차원 배열의 sum() 함수는 그 결과 값이 항상 2차원 배열 형태가 된다


```python
a = np.arange(12).reshape(3,2,2)
a
```




    array([[[ 0,  1],
            [ 2,  3]],
    
           [[ 4,  5],
            [ 6,  7]],
    
           [[ 8,  9],
            [10, 11]]])




```python
a[0,1,1]   # a[0][1][1] 과 동일한 개념
```




    3




```python
a[0,1].sum()
```




    5




```python
a[0,:,1].sum()
```




    4




```python
a[0].sum()  # 3차원구조의 1개면에서의 합
```




    6




```python
a[:1].sum()  # 3차원구조 0번면에서의 합(1은 stop 이므로 제외)
```




    6




```python
a[1:3].sum()
```




    60




```python
a.sum()  # 3차원 배열 전체의 합
```




    66




```python
a[:2,:2,:2].sum()
```




    28




```python
a[0].sum(axis=0)
```




    array([2, 4])




```python
a.sum()  # 축을 지정하지 않으면 방향을 무시하고 모든 원소를 합산
```




    66




```python
a.sum(axis=0)  # 3차원의 면방향 축으로 합산
```




    array([[12, 15],
           [18, 21]])




```python
a.sum(axis=1)
```




    array([[ 2,  4],
           [10, 12],
           [18, 20]])




```python
a.sum(axis=2)
```




    array([[ 1,  5],
           [ 9, 13],
           [17, 21]])




```python
a = np.arange(16).reshape(2,2,2,2)  # 축이 4개
a
```




    array([[[[ 0,  1],
             [ 2,  3]],
    
            [[ 4,  5],
             [ 6,  7]]],
    
    
           [[[ 8,  9],
             [10, 11]],
    
            [[12, 13],
             [14, 15]]]])




```python
a.sum()  # 4차원 배열 원소의 총합
```




    120




```python
a[1,1,1,1]
```




    15




```python
a[0:1,0,1,:].sum()
```




    5




```python
a.sum(axis=0)
```




    array([[[ 8, 10],
            [12, 14]],
    
           [[16, 18],
            [20, 22]]])




```python
a = np.arange(16).reshape(4,4)
a
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15]])




```python
a.mean()
```




    7.5




```python
a.mean(axis=1)
```




    array([ 1.5,  5.5,  9.5, 13.5])




```python
a.mean(axis=0)
```




    array([6., 7., 8., 9.])




```python
a.std()
```




    4.6097722286464435




```python
a.std(axis=0)
```




    array([4.47213595, 4.47213595, 4.47213595, 4.47213595])




```python
a.std(axis=1)
```




    array([1.11803399, 1.11803399, 1.11803399, 1.11803399])




```python
np.exp(1)   # 지수함수( e^x), e=2.718281828
```




    2.718281828459045




```python
np.sqrt(9)   # 제곱근
```




    3.0




```python
np.log10(100)  # 상용로그
```




    2.0




```python
np.log(np.e)  # 자연상수 e를 밑으로 하는 자연로그
```




    1.0




```python
np.log2(8)
```




    3.0




```python
import math
math.log(8,2)   # math 모듈을 이용한 일반 로그(2가 밑)
```




    3.0




```python
np.log(8)/np.log(2)  # 로그의 성질을 이용한 위의 로그 분해
```




    3.0




```python
np.exp(a)
```




    array([[1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01],
           [5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03],
           [2.98095799e+03, 8.10308393e+03, 2.20264658e+04, 5.98741417e+04],
           [1.62754791e+05, 4.42413392e+05, 1.20260428e+06, 3.26901737e+06]])



## 배열 합치기
vstack, hstack, concatenate


```python
a = np.arange(4)
b = np.arange(4)

np.vstack((a,b))  # 배열이 합쳐져서(행추가) 차원이 높아짐
```




    array([[0, 1, 2, 3],
           [0, 1, 2, 3]])




```python
np.hstack((a,b))  # 1차원배열 좌우로 더하면 1차원(Row Vector) 리턴
```




    array([0, 1, 2, 3, 0, 1, 2, 3])




```python
a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6]])

np.vstack((a,b))         # 행추가 (컬럼수가 동일해야 함)
```




    array([[1, 2],
           [3, 4],
           [5, 6]])




```python
np.hstack((a,b.T))         # 컬럼 추가(차원이 동일해야 함)
```




    array([[1, 2, 5],
           [3, 4, 6]])




```python
# vstack, hstack 함수를 concatenate()함수로 동일하게 표현할 수 있다
a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6]])

np.concatenate((a, b), axis=0)  # 행 추가(차원과 컬럼 수가 동일해야 함)
```




    array([[1, 2],
           [3, 4],
           [5, 6]])




```python
np.concatenate((a,b.T),axis=1)  # 컬럼 추가(행수가 서로 동일해야 함)
```




    array([[1, 2, 5],
           [3, 4, 6]])




```python
a = np.arange(9).reshape(3,3)
print(a)
print(a.T)
print(a.transpose())
```

    [[0 1 2]
     [3 4 5]
     [6 7 8]]
    [[0 3 6]
     [1 4 7]
     [2 5 8]]
    [[0 3 6]
     [1 4 7]
     [2 5 8]]
    


```python
# concatenate()를 이용한 행렬 합치기 실습
a = np.arange(9).reshape(3,3)
np.savetxt('D:/DataScience/np_conat.csv', a,fmt='%.1f', delimiter=',')

b = np.genfromtxt('D:/DataScience/np_conat.csv', dtype=float, delimiter=',')

mean_axis_1 = b.mean(axis=1)            # 가로 평균

mean_axis_1 = mean_axis_1.reshape(3,1)  # 행벡터->열벡터 변환
b2 = np.concatenate((b, mean_axis_1), axis=1)  # 원본행렬 우측에 평균 붙이기

mean_axis_0 = b2.mean(axis=0)           # 세로 평균
mean_axis_0 = mean_axis_0.reshape(1,4)  # 차원과 컬럼 수가 동일해야 함
b3 = np.concatenate((b2, mean_axis_0), axis=0)  # 원본행렬 하단에 세로평균 붙이기

np.savetxt('D:/DataScience/np_conat2.csv', b3,fmt='%.1f', delimiter=',')
```

## 가감승제
shape 이 동일하면 양 배열의 동일한 위치에 있는 원소들끼리 가감승제 연산이 이루어진다<br>
Matrix 연산 중에 내적(Dot Production)연산은 왼쪽 행렬의 행수와 오른쪽 행렬의 열수가 일치해야 한다. 그리고 왼쪽의 열수와 오른쪽의 행수가 일치해야 한다


```python
a = np.arange(6).reshape(2,3)
b = np.arange(2,8).reshape(2,3)
print(a)
print(b)
```

    [[0 1 2]
     [3 4 5]]
    [[2 3 4]
     [5 6 7]]
    


```python
a+b
a-b
a*b
a/b
```




    array([[0.        , 0.33333333, 0.5       ],
           [0.6       , 0.66666667, 0.71428571]])




```python
a = np.arange(6).reshape(2,3)
a
```




    array([[0, 1, 2],
           [3, 4, 5]])




```python
b = np.arange(6).reshape(3,2)
b
```




    array([[0, 1],
           [2, 3],
           [4, 5]])




```python
a.dot(b)   # 행렬의 내적연산
```




    array([[10, 13],
           [28, 40]])




```python
np.dot(a,b)
```




    array([[10, 13],
           [28, 40]])




```python
#np.dot(a,a)  # 오류(shapes (2,3) and (2,3) not aligned)
np.dot(a,a.T)
```




    array([[ 5, 14],
           [14, 50]])




```python
np.dot(a,a.transpose())
```




    array([[ 5, 14],
           [14, 50]])



## Broadcasting
배열의 shape이 다른 경우에 자동으로 적용되는 기능


```python
a = np.arange(6).reshape(2,3)
a
```




    array([[0, 1, 2],
           [3, 4, 5]])




```python
a+5
```




    array([[ 5,  6,  7],
           [ 8,  9, 10]])




```python
a-2
a*3
a/2
a//2   # 몫
a**3   # 제곱
```




    array([[  0,   1,   8],
           [ 27,  64, 125]], dtype=int32)




```python
a = np.arange(6).reshape(2,3)  # shape이 다른 경우의 계산
a
```




    array([[0, 1, 2],
           [3, 4, 5]])




```python
b = np.array([2,1,0])
b
```




    array([2, 1, 0])




```python
a+b
```




    array([[2, 2, 2],
           [5, 5, 5]])




```python
a = np.arange(3)   #
a
```




    array([0, 1, 2])




```python
b = np.arange(3).reshape(3,1)
b
```




    array([[0],
           [1],
           [2]])




```python
a+b
```




    array([[0, 1, 2],
           [1, 2, 3],
           [2, 3, 4]])



## 실행시간(성능) 측정, timeit 모듈 사용


```python
import timeit

def for_loop():
    sum =0
    for i in range(10000000):
       sum += i
    return sum
    
```


```python
%timeit for_loop()
```

    911 ms ± 249 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
    


```python
def test():
    for i in range(100000000):
        pass
%timeit test()
```

    2.4 s ± 277 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
    


```python
# 0~100만 까지의 수로 구성된 배열을 sample.csv으로 저장할 때 경과하는 시간 측정
import timeit

def timeit_save():
    a = np.arange(1000000).reshape(100000,10)
    np.savetxt('D:/DataScience/sample.csv', a, fmt='%d', delimiter=',')

def timeit_load():
    b =np.loadtxt('D:/DataScience/sample.csv', dtype=int, delimiter=',')

def timeit_load2():
    b =np.genfromtxt('D:/DataScience/sample.csv', dtype=int, delimiter=',')
    
%timeit timeit_save()
```

    644 ms ± 14.5 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
    


```python
# 동일한 기능을 하는 loadtxt(), genfromtxt() 성능비교
%timeit timeit_load()
%timeit timeit_load2()
```

    1.37 s ± 6.27 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
    1.27 s ± 2.72 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
    

## Comparisons ( all, any)


```python
a = np.arange(7)
np.any(a>3)  # a의 원소 중에서 어느 한개라도 3보다 크면 True
```




    True




```python
np.any(a<10)
```




    True




```python
a<5
```




    array([ True,  True,  True,  True,  True, False, False])




```python
a[a<5]
```




    array([0, 1, 2, 3, 4])




```python
np.any(a>5), np.all(a<8)
```




    (True, True)




```python
np.sum(a>3)  # True 의 갯수
```




    3




```python
np.sum(a[a>3])  # 3보다 큰 원소의 총합
```




    15




```python
a = np.array([1,2,3])
b = np.array([2,3,1])
a>b
```




    array([False, False,  True])




```python
a==b
```




    array([False, False, False])




```python
np.any(a>b)
```




    True




```python
(a>b).any()
```




    True




```python
a = np.array([1,2,3])
b = np.array([2,3,1])
np.logical_and(np.any(a<3), np.any(a>=0))   # 각원소를 대입하여 두 식이 참이면 True
```




    True




```python
np.logical_not((a<b).any())
```




    False




```python
np.logical_or(np.any(a>b), np.any(b<a))
```




    True




```python
not (True or False)
```




    False




```python
#  sample.csv 파일로 부터 데이터(float)를 로드할 때 그 중에 빈 값이
#  있는지 확인하고 빈 값이 몇개인지 확인하고 그 값을 0.0으로 변경해보세요.
#a = np.random.random(16).reshape(4,4)
#np.savetxt('D:/DataScience/np_any.csv', a, fmt='%.3f', delimiter=',')

b = np.genfromtxt('D:/DataScience/np_any.csv', dtype=float, delimiter=',')
#b = np.loadtxt('D:/DataScience/np_any.csv', dtype=float, delimiter=',')
print(b)
barr = np.isnan(b)
cnt = np.sum(barr)
print('결측값의 갯수:', cnt)
b[barr] = 0
print(b)
```

    [[0.643   nan 0.02  0.733]
     [0.066 0.706   nan 0.676]
     [0.547 0.03  0.982 0.446]
     [0.236 0.748 0.574 0.214]]
    결측값의 갯수: 2
    [[0.643 0.    0.02  0.733]
     [0.066 0.706 0.    0.676]
     [0.547 0.03  0.982 0.446]
     [0.236 0.748 0.574 0.214]]
    


```python
# 파일에서 로드된 데이터 중에서 0.5 이상의 값을 모두 1.0으로 변경하고,
# 0.5보다 작은 값은 0.0으로 변경하여 다른 파일에 저장해보세요.

a = np.genfromtxt('D:/DataScience/np_any.csv', dtype=float, delimiter=',')
a[np.isnan(a)] = 0.0
a[a>=0.5] = 1.0
a[a<0.5] = 0.0
print(a)
np.savetxt('D:/DataScience/np_any01.csv',a, fmt='%.1f', delimiter=',')
```

    [[1. 0. 0. 1.]
     [0. 1. 0. 1.]
     [1. 0. 1. 0.]
     [0. 1. 1. 0.]]
    

## np.where


```python
a = np.array([1,2,3])

np.where(a>2, 'A','B')  # 참이면 'A', 아니면 'B'
```




    array(['B', 'B', 'A'], dtype='<U1')




```python
np.where(a>0)  # 식이 참일 때의 인덱스
```




    (array([0, 1, 2], dtype=int64),)




```python
# 로드된 데이터의 빈 값을 찾아 100으로 변경하는 예
a = np.genfromtxt('D:/DataScience/np_any.csv', dtype=float, delimiter=',')
b = np.where(np.isnan(a))
print(b)
a[b] = 123
a
```

    (array([0, 1], dtype=int64), array([1, 2], dtype=int64))
    




    array([[6.43e-01, 1.23e+02, 2.00e-02, 7.33e-01],
           [6.60e-02, 7.06e-01, 1.23e+02, 6.76e-01],
           [5.47e-01, 3.00e-02, 9.82e-01, 4.46e-01],
           [2.36e-01, 7.48e-01, 5.74e-01, 2.14e-01]])




```python
np.isnan([1,2,np.nan,4,np.nan,6])
```




    array([False, False,  True, False,  True, False])




```python
np.isfinite([1,2,np.pi,4,np.e,6,])  # 숫자가 아니거나 양의 무한, 음의 무한인 경우
```




    array([ True,  True,  True,  True,  True,  True])




```python
a = np.array([2,3,4])
a[a>3]   # True 인 원소의 값을 모아서 배열생성
```




    array([4])




```python
a = np.arange(9).reshape(3,3)
np.where(a>3)   # True 인 원소는 5로 변경(boolean index)
a[a>3] = 5
a
```




    array([[0, 1, 2],
           [3, 5, 5],
           [5, 5, 5]])



## argmax, argmin
가장 큰 원소의 인덱스, 가장 작은 원소의 인덱스


```python
a = np.arange(9)
a
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8])




```python
np.argmax(a), np.argmin(a)
```




    (8, 0)




```python
a = a.reshape(3,3)
a
```




    array([[0, 1, 2],
           [3, 4, 5],
           [6, 7, 8]])




```python
np.argmax(a, axis=0)
```




    array([2, 2, 2], dtype=int64)




```python
np.argmin(a, axis=1)
```




    array([0, 0, 0], dtype=int64)



## Boolean index


```python
a = np.array([1,3,5,7])
a[[False,True,False,True]]  # True 인 위치의 값만 배열로 리턴됨
```




    array([3, 7])




```python
a[a>3]
```




    array([5, 7])




```python
(a>3).astype(np.int)  # boolean 배열을 정수배열로 변환
```




    array([0, 0, 1, 1])




```python
np.arange(4).astype(np.bool)   # 정수배열을 boolean 배열로 변환
```




    array([False,  True,  True,  True])



## Fancy index


```python
a = np.arange(10,5,-1)
b = [0,1,0,2]
a[b]
```




    array([10,  9, 10,  8])




```python
b = np.array([1,3,4,2,0,2,1,4,2,])  # 반드시 정수만 Fancy index로 사용
a[b]
```




    array([ 9,  7,  6,  8, 10,  8,  9,  6,  8])




```python
a.take(b)  # 위와 동일한 결과
```




    array([ 9,  7,  6,  8, 10,  8,  9,  6,  8])




```python
a = np.arange(9).reshape(3,3)
a
```




    array([[0, 1, 2],
           [3, 4, 5],
           [6, 7, 8]])




```python
b = np.array([1,2,0,1])
c = np.array([2,1,1,0])
a[b,c]
```




    array([5, 7, 1, 3])



## File IO
numpy 데이터를 binary 형태로 저장할 때는 save(), 다시 읽어 올 때는 load()<br>
numpy 데이터를 csv 포맷의 텍스트로 저장할 때는 savetext(), 읽어 올 때는 loadtext()


```python
a = np.arange(16).reshape(4,4)
a
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15]])




```python
# binary 형태로 파일에 저장하기
np.save('C:/test/numpy_bin',a)  # 확장자는 자동으로 .npy가 된다
```


```python
b = np.load('C:/test/numpy_bin.npy')  # 읽어 올 때는 확장자가 필요함
b
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15]])




```python
# CSV 포맷의 텍스트 파일에 numpy 데이터 저장하기(정수는 float 형으로 저장됨)
np.savetxt('C:/test/numpy_text.csv', a, delimiter=',')
# 저장할 때, fmt='%d' 으로 하면 정수로 저장된다
```


```python
b = np.loadtxt('C:/test/numpy_text.csv', delimiter=',')
# 읽어올 때 dtype='int' 으로 하면 정수로 읽어 올 수 있다
b   # 디폴트라면 float 형으로 저장되어 있다
```




    array([[ 0.,  1.,  2.,  3.],
           [ 4.,  5.,  6.,  7.],
           [ 8.,  9., 10., 11.],
           [12., 13., 14., 15.]])




```python
b.astype(np.int)  # float 형의 데이터를 int 형으로 변환
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15]])




```python
# np.getfromtxt()를 사용하면 결측값을 인식하여 다른 값으로 대치 가능
import numpy as np
a = np.random.randn(100).reshape(10,10)

import matplotlib.pyplot as plt
%matplotlib inline
plt.hist(a.flatten(), bins=100)
plt.show()

#np.savetxt('D:/DataScience/np_randn.csv', a, fmt='%.1f', delimiter=',')

#b = np.genfromtxt('D:/DataScience/np_randn.csv',dtype=float, delimiter=',',
#                missing_values='', filling_values='0.0')
#print(b)

```


![png](output_239_0.png)



```python
# genfromtxt, missing_value 

b = np.genfromtxt('D:/DataScience/np_randn.csv',dtype=float, delimiter=',',
                missing_values='', filling_values='0.0')
b[0,0] = np.nan
np.savetxt('D:/DataScience/np_save_nan.csv',b, fmt='%.1f', delimiter=',')
```


```python
#a = np.arange(16).reshape(4,4)
#np.savetxt('D:/DataScience/np_int_nan.csv',a, fmt='%d', delimiter=',')

b = np.loadtxt('D:/DataScience/np_int_nan.csv', dtype='U5', delimiter=',')
print(b)
b[b==''] = '0'  # 데이터가 빈 곳에 0을 입력한다
c = b.astype(int)
c.sum(axis=1)

```

    [['0' '' '2' '3']
     ['4' '' '6' '7']
     ['8' '9' '10' '11']
     ['12' '13' '14' '15']]
    




    array([ 5, 17, 38, 54])




```python
# 결측값이 있는 행을 삭제하는 예
a = np.loadtxt('D:/DataScience/np_int_nan.csv', dtype='U5', delimiter=',')
print(a)
# a[[False,False, True, True]]
a[(a!='').all(axis=1)]
# a[[ (i!='').all() for i in a]]
```

    [['0' '' '2' '3']
     ['4' '' '6' '7']
     ['8' '9' '10' '11']
     ['12' '13' '14' '15']]
    




    array([['8', '9', '10', '11'],
           ['12', '13', '14', '15']], dtype='<U5')



## 다차원 배열의 축방향 계산에 대한 이해


```python
# 다차원 배열의 축에 대한 이해
a = np.arange(16).reshape(2,2,2,2)
print(a)
a.sum(axis=0)  # 4차원 축방향으로 합산()
# 4차원배열의 원소는 3차원으로 구성됨
# 4차원을 구성하는 3차원 배열을 겹쳐 놓고 볼 때 서로 만나는 숫자끼리 덧셈
# 4차원배열의 합산은 3차원 배열로 표현된다
```

    [[[[ 0  1]
       [ 2  3]]
    
      [[ 4  5]
       [ 6  7]]]
    
    
     [[[ 8  9]
       [10 11]]
    
      [[12 13]
       [14 15]]]]
    




    array([[[ 8, 10],
            [12, 14]],
    
           [[16, 18],
            [20, 22]]])



## numpy 배열의 정렬(sort)


```python
a = np.random.randint(0,15,16).reshape(4,4)
a
```




    array([[13,  8,  0, 10],
           [ 2, 12,  2, 12],
           [ 8,  8,  8, 12],
           [ 3, 10,  9,  4]])




```python
# 오름차순 정렬
np.sort(a, axis=0)  # np.sort(a, axis=0)[::1]와 동일
```




    array([[ 2,  8,  0,  4],
           [ 3,  8,  2, 10],
           [ 8, 10,  8, 12],
           [13, 12,  9, 12]])




```python
# 내림차순 정렬
np.sort(a, axis=0)[::-1]
```




    array([[13, 12,  9, 12],
           [ 8, 10,  8, 12],
           [ 3,  8,  2, 10],
           [ 2,  8,  0,  4]])




```python
# 좌우 오름차순 정렬
np.sort(a, axis=1)  # np.sort(a, axis=1)[:,::1] 과 동일
```




    array([[ 0,  8, 10, 13],
           [ 2,  2, 12, 12],
           [ 8,  8,  8, 12],
           [ 3,  4,  9, 10]])




```python
# 좌우 내림차순 정렬
np.sort(a, axis=1)[:,::-1]
```




    array([[13, 10,  8,  0],
           [12, 12,  2,  2],
           [12,  8,  8,  8],
           [10,  9,  4,  3]])




```python
# 상하 내림차순, 좌우 내림차순 결합
a2 = np.sort(a,axis=0)[::-1]
print(a2)
a3 = np.sort(a2, axis=1)[:,::-1]
print(a3)
```

    [[13 12  9 12]
     [ 8 10  8 12]
     [ 3  8  2 10]
     [ 2  8  0  4]]
    [[13 12 12  9]
     [12 10  8  8]
     [10  8  3  2]
     [ 8  4  2  0]]
    

## 결측값 대치 실습문제
4x4 양수 행렬을 생성하고 한군데를 음수로 설정
다른 한군데는 결측값으로 비운다
source.csv 파일에 저장
파일 읽어오기, 음수행 제거, 결측값은 해당 컬럼 평균으로 대치
결과를 파일에 저장


```python
a = np.arange(16).reshape(4,4)
a[0,0] = -1    # 음수 입력
sa = a.astype(str)
sa[2,2] = ''   # 결측값 
print(sa)

np.savetxt('D:/DataScience/np_strarr.csv', sa, fmt='%s', delimiter=',')
b = np.loadtxt('D:/DataScience/np_strarr.csv', dtype='U5', delimiter=',')
b2 = b[(b!='-1').all(axis=1)]  # 음수를 포함한 행 제거
print(b2)

b2[b2==''] = '0' 
b3 = b2.astype(np.int)  # 정수 배열로 변환
print(b3)
row_cnt = len(b3)                      # 행수

col_mean = b3.sum(axis=0)/(row_cnt-1)  # 세로축 평균
pos = np.where(b3==0)                  # 0값을 가진 위치확인
print('결측값 위치:',pos[1])
m = col_mean[pos[1]]                   # 결측값을 가진 컬럼 평균

b3[b3==0] = m                          # 0인 위치에 해당 컬럼의 평균 입력
print(b3)
                                       # 결과를 파일에 저장
np.savetxt('D:/DataScience/np_result.csv',b3, fmt='%d', delimiter=',')
```

    [['-1' '1' '2' '3']
     ['4' '5' '6' '7']
     ['8' '9' '' '11']
     ['12' '13' '14' '15']]
    [['4' '5' '6' '7']
     ['8' '9' '' '11']
     ['12' '13' '14' '15']]
    [[ 4  5  6  7]
     [ 8  9  0 11]
     [12 13 14 15]]
    결측값 위치: [2]
    [[ 4  5  6  7]
     [ 8  9 10 11]
     [12 13 14 15]]
    


```python
# 결측값 대치 실습문제
# 무작위 실수로 4x4 행렬을 생성하고, 
#	데이터 중에서 임의의 위치에 결측값을 설정하고,
#	np_rand.csv 파일에 저장한다.
#	다시 파일을 읽어 들여서 numpy 배열을 생성하고,
#	결측값을 다른 값으로 입력하는데 다음 요구사항을 따른다.
#	결측값의 상하의 위치에 있는 값을 복사하여 결측치에 입력한다.
#	먼저 위에 있는 값을 고려하고 불가할 시 아래에 있는 값을 사용한다.
#	완성된 행렬을 np_rand02.csv 파일에 저장한다.
```


```python
import numpy as np
a = np.random.random(16).reshape(4,4)
a[1,1] = np.nan
np.savetxt('D:/DataScience/np_rand.csv', a, fmt='%.3f', delimiter=',')
b = np.loadtxt('D:/DataScience/np_rand.csv', dtype=float, delimiter=',')
print(b)
empty_pos = np.where(np.isnan(b))  # 결측값 위치 확인
print(type(empty_pos), empty_pos)
_empty_pos = list(empty_pos)       # 원소변경이 가능한 list 로 변환
if _empty_pos[0] >0 :              # 결측값 위에 있는 값이 가능한지 확인
    _empty_pos[0]-=1               # 위의 값 인덱스 구함
else:
    _empty_pos[0]+=1               # 아래에 있는 값의 인덱스 구함
rep_val = b[_empty_pos[0],_empty_pos[1]]  # 결측값의 위치에 사용할 값 구함
b[np.isnan(b)] = rep_val                  # 결측값을 새로운 값으로 대치함
print()
print(b)                                  # 결측값이 대치된 행렬을 파일에 저장
np.savetxt('D:/DataScience/np_rand.csv',b,fmt='%.3f', delimiter=',')
print('\n--> 결과행렬 파일저장 완료')
```

    [[0.23  0.139 0.031 0.724]
     [0.843   nan 0.57  0.244]
     [0.265 0.324 0.26  0.055]
     [0.889 0.222 0.849 0.703]]
    <class 'tuple'> (array([1], dtype=int64), array([1], dtype=int64))
    
    [[0.23  0.139 0.031 0.724]
     [0.843 0.139 0.57  0.244]
     [0.265 0.324 0.26  0.055]
     [0.889 0.222 0.849 0.703]]
    
    --> 결과행렬 파일저장 완료
    

## numpy를 이용한 데이터 정렬
상하/좌우, 오름차순/내림차순 정렬


```python
a = np.random.randint(0,100,16).reshape(4,4)
b = np.sort(a, axis=1)[:,::-1]
c = np.sort(b, axis=0)[::-1]
c
```




    array([[97, 85, 60, 10],
           [85, 78, 53,  9],
           [79, 67, 46,  9],
           [51, 46, 43,  1]])



## 정렬 실습
0~15까지 저장한 4x4 행렬을 생성하고,
좌우 내림차순으로 정렬하여, 행렬을 좌우로 분리하여
따로 파일에 각각 저장한다.
다시 2개의 파일을 로드하여 행렬을 생성하고, 각각의 행열을 
상하 내림차순으로 정렬하여, 그 결과 행렬을 결합하여 화면에 표시


```python
a = np.random.randint(0,15,16).reshape(4,4)
print(a)
b = np.sort(a,axis=0)[::-1]
print(b)
splited = np.split(b,2, axis=1)
np.savetxt('D:/DataScience/np_split_0.csv', splited[0], fmt='%d', delimiter=',')
np.savetxt('D:/DataScience/np_split_1.csv', splited[1], fmt='%d', delimiter=',')
print('분리하여 파일에 저장 완료')
c = np.loadtxt('D:/DataScience/np_split_0.csv', dtype=int, delimiter=',')
d = np.loadtxt('D:/DataScience/np_split_1.csv', dtype=int, delimiter=',')
c = np.sort(c, axis=0)[::-1]
d = np.sort(d, axis=0)[::-1]
e = np.hstack((c,d))
e
```

    [[ 0  4  3 11]
     [ 1  9  1  2]
     [ 7  6  0  6]
     [ 4 13  3  9]]
    [[ 7 13  3 11]
     [ 4  9  3  9]
     [ 1  6  1  6]
     [ 0  4  0  2]]
    분리하여 파일에 저장 완료
    




    array([[ 7, 13,  3, 11],
           [ 4,  9,  3,  9],
           [ 1,  6,  1,  6],
           [ 0,  4,  0,  2]])



## numpy 배열에 행 추가
행 추가는 1차원 구조를 생성하여 전달<br>
np.insert(a, [행번호], [1,2,3], axis=0) # a 2차원배열에 새로운 행 추가<br>
컬럼 추가는 2차원 구조를 생성하여 전달<br>
np.insert(a, [컬럼번호], [[1],[2],[3]], axis=1) # a 2차원배열에 새로운 컬럼 추가<br>


```python
a = np.arange(9).reshape(3,3)
print(a)
import matplotlib.pyplot as plt
plt.plot(a)
plt.show()

plt.hist(a, bins=9)
plt.show()
```

    [[0 1 2]
     [3 4 5]
     [6 7 8]]
    


![png](output_261_1.png)



![png](output_261_2.png)


## 최종실습


```python
# Question 1: 무작위 실수로 구성된 4x2 행렬을 생성하고 화면에 표시
np.random.random(8).reshape(4,2)
```




    array([[0.03901121, 0.38010668],
           [0.01354823, 0.12126578],
           [0.58472661, 0.70719326],
           [0.08684589, 0.41568977]])




```python
# Question 2: 정수(100~200)로 5x2 행렬 생성(원소들의 차이가 10이 되도록)
np.array([i for i in np.arange(100,200,10)]).reshape(5,2)
```




    array([[100, 110],
           [120, 130],
           [140, 150],
           [160, 170],
           [180, 190]])




```python
# Question 3: 4x4 정수행렬을 생성하고 세번째 컬럼만 모두 가져와서 표시하기
a = np.arange(16).reshape(4,4)
print(a)
a[:,2]
```

    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]
     [12 13 14 15]]
    




    array([ 2,  6, 10, 14])




```python
# Question 4: 4x4 정수행렬을 생성하고 홀수행과 짝수 컬럼을 선택하여 표시
a = np.arange(16).reshape(4,4)
print(a)
a[::2,1::2]
```

    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]
     [12 13 14 15]]
    




    array([[ 1,  3],
           [ 9, 11]])




```python
# Question 5: 두행렬을 더하고 그 결과 배열에 제곱하여 표시
a = np.arange(9).reshape(3,3)
b = a[::-1]
c = a+b
print(c)
c**2
```

    [[ 6  8 10]
     [ 6  8 10]
     [ 6  8 10]]
    




    array([[ 36,  64, 100],
           [ 36,  64, 100],
           [ 36,  64, 100]], dtype=int32)




```python
# uestion 6: 4x4 정수행렬을 생성하고 4개의 모양이 동일한 행렬로 분리하여 표시
a = np.arange(16).reshape(4,4)
print(a)
a1 = a[:2:,:2]
a2 = a[:2,2:4]
a3 = a[2:4,:2]
a4 = a[2:4,2:4]
print(a1)
print(a2)
print(a3)
print(a4)
```

    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]
     [12 13 14 15]]
    [[0 1]
     [4 5]]
    [[2 3]
     [6 7]]
    [[ 8  9]
     [12 13]]
    [[10 11]
     [14 15]]
    


```python
# Question 7; 무작위 정수 4x4 행렬을 생성하고 상하 오름차순,좌우 오름차순으로 정렬하여 표시
a = np.random.randint(0,15,16).reshape(4,4)
b = np.sort(np.sort(a, axis=0), axis=1)
b
```




    array([[ 1,  1,  4,  5],
           [ 2,  2,  7,  9],
           [ 2,  7,  9,  9],
           [ 3,  7, 10, 12]])




```python
# Question 8: 0~15로 구성된 4x4 행렬을 생성하고 행축방향으로 최대값과 컬럼방향으로 최소값을 구하여 표시
a = np.arange(16).reshape(4,4)
print(a)
max_axis_0 = np.max(a, axis=0)
max_axis_1 = np.max(a, axis=1)
print('세로 최대값:',max_axis_0)
print('가로 최대값:',max_axis_1)
```

    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]
     [12 13 14 15]]
    세로 최대값: [12 13 14 15]
    가로 최대값: [ 3  7 11 15]
    


```python
# Question 9: 3x3 정수행렬을 생성하고 중간 행을 삭제하고, 새로운 1x3 배열을 생성하여 삽입
a = np.arange(9).reshape(3,3)
print(a)
b = a[[0,2]]
print('중간행 삭제:\n',b)
c = np.random.randint(0,20,3)
print('새로 추가할 행:',c)
print('추가한 결과')
np.insert(b,[1], c,axis=0)
```

    [[0 1 2]
     [3 4 5]
     [6 7 8]]
    중간행 삭제:
     [[0 1 2]
     [6 7 8]]
    새로 추가할 행: [17 14  1]
    추가한 결과
    




    array([[ 0,  1,  2],
           [17, 14,  1],
           [ 6,  7,  8]])




```python
# Question 10: 2차원 배열을 생성하고 matplotlib 모듈을 사용하여 그래프를 그린다
a = np.random.randint(-10,10,100).reshape(20,5)
b = np.cumsum(a, axis=1)
b = np.cumsum(b, axis=0)
import matplotlib.pyplot as plt
%matplotlib inline
plt.plot(b)
plt.show()
```


![png](output_272_0.png)

